const venom = require('venom-bot');
const express = require('express');
const bodyParser = require('body-parser');
const fs = require('fs');
const path = require('path');

const app = express();
app.use(bodyParser.json());

let venomClient = null;
let qrCode = null;
let isCreatingClient = false;
let botStatus = {
    connected: false,
    status: 'Iniciando...',
    lastUpdate: new Date()
};

console.log('üöÄ Iniciando bot de WhatsApp...');

// Configurar CORS para desarrollo local
app.use((req, res, next) => {
    res.header('Access-Control-Allow-Origin', '*');
    res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
    res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
    
    if (req.method === 'OPTIONS') {
        res.sendStatus(200);
    } else {
        next();
    }
});

// üîÑ FUNCI√ìN PARA LIMPIAR COMPLETAMENTE LA SESI√ìN
function cleanSession(sessionName = 'my-session') {
    try {
        const pathsToClean = [
            `./tokens`,
            `./tokens/${sessionName}`,
            `./tokens/${sessionName}.data.json`,
            `./${sessionName}.data.json`,
            `./session`,
            `./session/${sessionName}`,
            // Limpiar posibles carpetas de Chrome/Chromium
            `./chrome-session`,
            `./chrome-data`,
            `./browser-data`
        ];
        
        pathsToClean.forEach(sessionPath => {
            if (fs.existsSync(sessionPath)) {
                if (fs.statSync(sessionPath).isDirectory()) {
                    fs.rmSync(sessionPath, { recursive: true, force: true });
                    console.log(`üìÅ Carpeta eliminada: ${sessionPath}`);
                } else {
                    fs.unlinkSync(sessionPath);
                    console.log(`üóÉÔ∏è Archivo eliminado: ${sessionPath}`);
                }
            }
        });
        
        console.log('‚úÖ Sesi√≥n limpiada completamente');
        return true;
    } catch (error) {
        console.error('‚ùå Error limpiando sesi√≥n:', error);
        return false;
    }
}

// üîÑ RUTA PARA LIMPIAR SESI√ìN COMPLETAMENTE
app.post('/reset-session', async (req, res) => {
    console.log('üîÑ Solicitud para resetear sesi√≥n completamente...');
    
    // Prevenir m√∫ltiples resets simult√°neos
    if (isCreatingClient) {
        return res.status(429).json({
            success: false,
            message: 'Ya hay un reset en progreso, espera un momento...'
        });
    }
    
    try {
        // Cerrar cliente actual si existe
        if (venomClient) {
            try {
                await venomClient.close();
                console.log('üîå Cliente existente cerrado');
            } catch (error) {
                console.error('Error cerrando cliente:', error);
            }
            venomClient = null;
        }
        
        // Resetear estado
        qrCode = null;
        botStatus = {
            connected: false,
            status: 'Reseteando...',
            message: 'Eliminando sesi√≥n y datos de navegador...',
            lastUpdate: new Date()
        };
        
        // Limpiar sesi√≥n completamente
        const cleanSuccess = cleanSession();
        
        // Esperar un momento antes de recrear
        setTimeout(() => {
            console.log('üîÑ Recreando cliente despu√©s del reset...');
            createVenomClient();
        }, 3000);
        
        res.json({
            success: true,
            message: 'Sesi√≥n reseteada completamente. Nuevo cliente inici√°ndose...',
            status: botStatus
        });
        
    } catch (error) {
        console.error('‚ùå Error en reset:', error);
        res.status(500).json({
            success: false,
            message: 'Error al resetear: ' + error.message
        });
    }
});

// Crear cliente con configuraci√≥n optimizada para Chrome Linux
function createVenomClient() {
    if (isCreatingClient) {
        console.log('‚ö†Ô∏è Ya hay un cliente cre√°ndose, saltando...');
        return;
    }
    
    isCreatingClient = true;
    console.log('üîß Creando cliente de Venom con configuraci√≥n optimizada...');
    
    // Configuraci√≥n espec√≠fica para solucionar problemas de Chrome en Linux
    const venomOptions = {
        session: 'my-session',
        multidevice: true,
        headless: true,
        logQR: false,
        disableSpins: true,
        autoClose: 60000, // 60 segundos de timeout
        
        // üîß CONFIGURACI√ìN ESPEC√çFICA PARA CHROME LINUX
        browserArgs: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-accelerated-2d-canvas',
            '--no-first-run',
            '--no-zygote',
            '--disable-gpu',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding',
            '--disable-features=TranslateUI',
            '--disable-ipc-flooding-protection',
            '--disable-extensions',
            '--disable-default-apps',
            '--disable-sync',
            '--disable-translate',
            '--hide-scrollbars',
            '--mute-audio',
            '--no-default-browser-check',
            '--no-pings',
            '--single-process', // Esto puede ayudar con problemas de memoria
            '--disable-web-security',
            '--disable-features=VizDisplayCompositor'
        ],
        
        // Configuraciones adicionales para estabilidad
        puppeteerOptions: {
            headless: true,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-accelerated-2d-canvas',
                '--no-first-run',
                '--no-zygote',
                '--disable-gpu'
            ]
        },
        
        // Callbacks mejorados
        catchQR: (base64Qr, asciiQR, attempts, urlCode) => {
            console.log(`üì± C√≥digo QR generado (intento ${attempts})`);
            console.log('üì± QR ASCII en terminal:');
            console.log(asciiQR);
            
            qrCode = base64Qr;
            botStatus = {
                connected: false,
                status: 'Esperando QR',
                message: `Escanea el c√≥digo QR para conectar WhatsApp (intento ${attempts}/5)`,
                lastUpdate: new Date(),
                attempts: attempts
            };
            
            // Si han fallado muchos intentos, sugerir reset
            if (attempts >= 3) {
                console.log('‚ö†Ô∏è Muchos intentos de QR, puede necesitar reset completo');
            }
        },
        
        statusFind: (statusSession, session) => {
            console.log(`üìä Estado de sesi√≥n: ${statusSession} | Sesi√≥n: ${session}`);
            
            switch(statusSession) {
                case 'notLogged':
                    botStatus = {
                        connected: false,
                        status: 'No conectado',
                        message: 'Necesitas escanear el c√≥digo QR',
                        lastUpdate: new Date()
                    };
                    break;
                    
                case 'qrReadSuccess':
                    botStatus = {
                        connected: false,
                        status: 'QR Escaneado',
                        message: 'QR escaneado exitosamente, conectando...',
                        lastUpdate: new Date()
                    };
                    qrCode = null;
                    break;
                    
                case 'chatsAvailable':
                    botStatus = {
                        connected: true,
                        status: 'Conectado',
                        message: 'WhatsApp Web conectado correctamente',
                        lastUpdate: new Date()
                    };
                    isCreatingClient = false;
                    break;
                    
                case 'qrReadFail':
                    console.log('‚ùå Fallo al leer QR');
                    botStatus = {
                        connected: false,
                        status: 'Error QR',
                        message: 'Fall√≥ la lectura del QR. Intenta nuevamente o resetea la sesi√≥n.',
                        lastUpdate: new Date()
                    };
                    break;
                    
                case 'waitForLogin':
                    console.log('‚è≥ Esperando login...');
                    botStatus = {
                        connected: false,
                        status: 'Esperando Login',
                        message: 'Esperando que completes el login en WhatsApp...',
                        lastUpdate: new Date()
                    };
                    break;
                    
                case 'autocloseCalled':
                case 'browserClose':
                    console.log('üîå Navegador cerrado');
                    botStatus = {
                        connected: false,
                        status: 'Navegador cerrado',
                        message: 'El navegador se cerr√≥. Reinicia o resetea la sesi√≥n.',
                        lastUpdate: new Date()
                    };
                    isCreatingClient = false;
                    break;
                    
                case 'deleteToken':
                    console.log('üîÑ Token eliminado, preparando nueva sesi√≥n...');
                    botStatus = {
                        connected: false,
                        status: 'Token eliminado',
                        message: 'Token eliminado, creando nueva sesi√≥n...',
                        lastUpdate: new Date()
                    };
                    break;
                    
                default:
                    console.log(`‚ö†Ô∏è Estado no manejado: ${statusSession}`);
                    botStatus = {
                        connected: false,
                        status: `Estado: ${statusSession}`,
                        message: `Estado del bot: ${statusSession}`,
                        lastUpdate: new Date()
                    };
                    break;
            }
        }
    };
    
    venom
        .create(venomOptions)
        .then((client) => {
            console.log('‚úÖ Cliente de WhatsApp conectado exitosamente');
            venomClient = client;
            isCreatingClient = false;
            
            botStatus = {
                connected: true,
                status: 'Conectado',
                message: 'Bot funcionando correctamente',
                lastUpdate: new Date()
            };
            
            qrCode = null;
            start(client);
        })
        .catch((error) => {
            console.error('‚ùå Error conectando WhatsApp:', error);
            isCreatingClient = false;
            
            // Manejo espec√≠fico de errores
            let errorMessage = error.message || error.toString();
            
            if (errorMessage.includes('Page Closed')) {
                botStatus = {
                    connected: false,
                    status: 'Error - P√°gina cerrada',
                    message: 'La p√°gina de WhatsApp se cerr√≥ inesperadamente. Usa reset para reintentar.',
                    lastUpdate: new Date()
                };
            } else if (errorMessage.includes('Failed to authenticate')) {
                botStatus = {
                    connected: false,
                    status: 'Error - Autenticaci√≥n fallida',
                    message: 'Fall√≥ la autenticaci√≥n. Resetea la sesi√≥n e intenta nuevamente.',
                    lastUpdate: new Date()
                };
            } else if (errorMessage.includes('Checking is logged')) {
                botStatus = {
                    connected: false,
                    status: 'Error - Sesi√≥n bloqueada',
                    message: 'Sesi√≥n bloqueada en "Checking is logged". Resetea la sesi√≥n.',
                    lastUpdate: new Date()
                };
            } else {
                botStatus = {
                    connected: false,
                    status: 'Error de conexi√≥n',
                    message: 'Error al inicializar: ' + errorMessage.substring(0, 100),
                    lastUpdate: new Date()
                };
            }
            
            // Auto-retry despu√©s de 30 segundos si hay error
            console.log('üîÑ Reintentando conexi√≥n en 30 segundos...');
            setTimeout(() => {
                if (!venomClient) {
                    console.log('üîÑ Reintentando crear cliente...');
                    createVenomClient();
                }
            }, 30000);
        });
}

function start(client) {
    console.log('üåê Configurando servidor Express...');
    
    // Detectar cambios de estado para manejar desconexiones
    client.onStateChange((state) => {
        console.log('üîÑ Estado del cliente cambiado:', state);
        
        switch(state) {
            case 'CONFLICT':
                console.log('‚ö†Ô∏è Conflicto detectado - forzando tomar control');
                client.useHere();
                break;
                
            case 'UNPAIRED':
            case 'UNLAUNCHED':
                console.log('‚ùå Cliente desemparejado o no lanzado');
                botStatus = {
                    connected: false,
                    status: 'Desconectado',
                    message: `Estado: ${state}. Resetea la sesi√≥n si persiste.`,
                    lastUpdate: new Date()
                };
                break;
                
            case 'CONNECTED':
                console.log('‚úÖ Cliente conectado correctamente');
                botStatus = {
                    connected: true,
                    status: 'Conectado',
                    message: 'WhatsApp conectado y funcionando',
                    lastUpdate: new Date()
                };
                break;
        }
    });
    
    // Monitorear cambios de stream
    client.onStreamChange((state) => {
        console.log('üåä Estado de stream cambiado:', state);
        
        if (state === 'DISCONNECTED') {
            console.log('üì± Desconectado del tel√©fono');
            botStatus = {
                connected: false,
                status: 'Desconectado del tel√©fono',
                message: 'El tel√©fono se desconect√≥. Verifica la conexi√≥n.',
                lastUpdate: new Date()
            };
        } else if (state === 'CONNECTED') {
            console.log('üì± Reconectado al tel√©fono');
            botStatus = {
                connected: true,
                status: 'Conectado',
                message: 'Reconectado exitosamente',
                lastUpdate: new Date()
            };
        }
    });
    
    // TUS RUTAS ORIGINALES (sin cambios)
    app.post('/send-message', async (req, res) => {
        console.log('üì® Petici√≥n recibida para enviar mensaje');
        
        const { number, message } = req.body;
        
        if (!number || !message) {
            console.error('‚ùå Faltan datos: number o message');
            return res.status(400).json({ 
                status: 'error', 
                error: 'Faltan campos requeridos: number y message' 
            });
        }

        if (!botStatus.connected) {
            return res.status(503).json({
                status: 'error',
                error: 'Bot no est√° conectado. Verifica el estado en el dashboard.',
                botStatus: botStatus
            });
        }

        try {
            const formattedNumber = number.includes('@c.us') ? number : `${number}@c.us`;
            
            console.log(`üì§ Enviando mensaje a: ${formattedNumber}`);
            console.log(`üìù Mensaje: ${message.substring(0, 100)}${message.length > 100 ? '...' : ''}`);
            
            await client.sendText(formattedNumber, message);
            
            console.log('‚úÖ Mensaje enviado exitosamente');
            return res.status(200).json({ 
                status: 'enviado',
                number: formattedNumber,
                timestamp: new Date().toISOString()
            });
            
        } catch (err) {
            console.error('‚ùå Error enviando mensaje:', err);
            return res.status(500).json({ 
                status: 'error', 
                error: err.toString(),
                timestamp: new Date().toISOString()
            });
        }
    });

    app.post('/send-notification', async (req, res) => {
        console.log('üì® Petici√≥n recibida para enviar notificaci√≥n');
        
        const { number, message, imagePath } = req.body;
        
        if (!number || !message) {
            console.error('‚ùå Faltan datos: number o message');
            return res.status(400).json({ 
                status: 'error', 
                error: 'Faltan campos requeridos: number y message' 
            });
        }

        if (!botStatus.connected) {
            return res.status(503).json({
                status: 'error',
                error: 'Bot no est√° conectado',
                botStatus: botStatus
            });
        }

        try {
            const formattedNumber = number.includes('@c.us') ? number : `${number}@c.us`;
            
            console.log(`üì§ Enviando notificaci√≥n a: ${formattedNumber}`);
            
            if (imagePath) {
                try {
                    if (fs.existsSync(imagePath)) {
                        console.log(`üñºÔ∏è Enviando imagen: ${path.basename(imagePath)}`);
                        await client.sendImage(
                            formattedNumber,
                            imagePath,
                            path.basename(imagePath),
                            message
                        );
                        console.log('‚úÖ Imagen con mensaje enviada exitosamente');
                        return res.status(200).json({ 
                            status: 'enviado',
                            type: 'image_with_text',
                            number: formattedNumber,
                            timestamp: new Date().toISOString()
                        });
                    } else {
                        console.warn('‚ö†Ô∏è Imagen no encontrada, enviando solo texto');
                        await client.sendText(formattedNumber, message);
                    }
                } catch (imageError) {
                    console.error('‚ùå Error con imagen, enviando solo texto:', imageError);
                    await client.sendText(formattedNumber, message);
                }
            } else {
                console.log('üìù Enviando solo mensaje de texto');
                await client.sendText(formattedNumber, message);
            }
            
            console.log('‚úÖ Notificaci√≥n enviada exitosamente');
            return res.status(200).json({ 
                status: 'enviado',
                type: imagePath ? 'text_fallback' : 'text',
                number: formattedNumber,
                timestamp: new Date().toISOString()
            });
            
        } catch (err) {
            console.error('‚ùå Error enviando notificaci√≥n:', err);
            return res.status(500).json({ 
                status: 'error', 
                error: err.toString(),
                timestamp: new Date().toISOString()
            });
        }
    });

    // Ruta para obtener el estado del bot
    app.get('/status', (req, res) => {
        res.json({
            ...botStatus,
            hasQR: qrCode !== null,
            uptime: process.uptime(),
            isCreatingClient: isCreatingClient
        });
    });

    // Ruta para obtener el c√≥digo QR
    app.get('/qr', (req, res) => {
        if (qrCode) {
            res.json({
                success: true,
                qr: qrCode,
                status: 'QR disponible'
            });
        } else if (botStatus.connected) {
            res.json({
                success: false,
                message: 'Bot ya est√° conectado',
                status: 'connected'
            });
        } else {
            res.json({
                success: false,
                message: 'C√≥digo QR no disponible en este momento',
                status: botStatus.status
            });
        }
    });

    // Ruta de prueba mejorada
    app.get('/test', (req, res) => {
        res.json({ 
            status: 'Bot funcionando correctamente',
            features: ['text', 'image', 'notifications', 'qr', 'status', 'reset-session'],
            botStatus: botStatus,
            browserInfo: {
                platform: 'linux',
                chrome: '/usr/bin/google-chrome-stable'
            },
            timestamp: new Date().toISOString(),
            uptime: process.uptime()
        });
    });

    // Escuchar en puerto 3000
    app.listen(3000, () => {
        console.log('üöÄ Servidor de VenomBot activo en puerto 3000');
        console.log('üì± Endpoints disponibles:');
        console.log('  - POST /send-message (mensaje de texto)');
        console.log('  - POST /send-notification (texto o imagen+texto)');
        console.log('  - POST /reset-session (limpiar sesi√≥n completamente) üîÑ');
        console.log('  - GET /status (estado del bot)');
        console.log('  - GET /qr (c√≥digo QR para conectar)');
        console.log('  - GET /test (verificar estado)');
        console.log('üåê Listo para recibir peticiones de Laravel');
        console.log('');
        console.log('üí° SOLUCI√ìN PARA ERRORES:');
        console.log('   1. Si ves "Page Closed" o "Failed to authenticate":');
        console.log('      curl -X POST http://localhost:3000/reset-session');
        console.log('   2. Espera 30 segundos y verifica: curl http://localhost:3000/status');
        console.log('   3. Si persiste, reinicia completamente: pkill node && node bot.js');
    });
}

// Inicializar el cliente
createVenomClient();

// Manejar errores globales
process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
    botStatus = {
        connected: false,
        status: 'Error interno',
        message: 'Error interno del bot: ' + reason,
        lastUpdate: new Date()
    };
});

process.on('uncaughtException', (error) => {
    console.error('‚ùå Uncaught Exception:', error);
    botStatus = {
        connected: false,
        status: 'Error cr√≠tico',
        message: 'Error cr√≠tico del bot: ' + error.message,
        lastUpdate: new Date()
    };
});

// Cerrar correctamente al terminar
process.on('SIGINT', function() {
    console.log('üõë Cerrando bot correctamente...');
    if (venomClient) {
        venomClient.close().then(() => {
            console.log('‚úÖ Cliente cerrado correctamente');
            process.exit(0);
        });
    } else {
        process.exit(0);
    }
});

process.on('SIGTERM', function() {
    console.log('üõë Terminando bot...');
    if (venomClient) {
        venomClient.close().then(() => {
            process.exit(0);
        });
    } else {
        process.exit(0);
    }
});
